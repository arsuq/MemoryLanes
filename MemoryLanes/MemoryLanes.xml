<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MemoryLanes</name>
    </assembly>
    <members>
        <member name="T:System.Collections.Concurrent.ConcurrentArray`1">
            <summary>
            Represents an ordered list of fix-sized arrays as one virtual contiguous array. 
            </summary>
            <remarks>
            Growing allocates as much new arrays as configured, each with the same BaseLength.
            </remarks>
            <typeparam name="T">A class</typeparam>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentArray`1.Gear">
            <summary>
            The allowed concurrent operations
            </summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentArray`1.Gear.N">
            <summary>
            Concurrent gets and sets are enabled, but not Append/Remove or Resize.
            </summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentArray`1.Gear.Straight">
            <summary>
            Concurrent Append(), gets and sets are enabled.
            </summary>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentArray`1.Gear.Reverse">
            <summary>
            Concurrent RemoveLast() gets and sets are enabled.
            </summary>
            <remarks>
            Getting or setting values in this mode is racing with the AppendPos.
            </remarks>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentArray`1.Gear.P">
            <summary>
            Only Resize() is allowed.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentArray`1.#ctor(System.Int32,System.Int32,System.Int32,System.Func{System.Collections.Concurrent.ConcurrentArray{`0},System.Int32})">
            <summary>
            Creates new Concurrent array with predefined max capacity = maxBlocksCount * blockLength.
            </summary>
            <param name="blockLength">The fixed length of the individual blocks</param>
            <param name="maxBlocksCount">The array cannot expand beyond that value</param>
            <param name="initBlocksCount">The number of blocks to allocate in the constructor</param>
            <param name="expansionLen">A callback invoked when more blocks are needed, 
            allowing a nonlinear expansion.</param>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentArray`1.BlockLength">
            <summary>
            The virtual array incremental size.
            </summary>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentArray`1.TotalMaxCapacity">
            <summary>
            Returns the product of all block slots (including the non allocated ones) and the BlockLength.
            </summary>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentArray`1.AppendIndex">
            <summary>
            The current set index. 
            </summary>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentArray`1.ItemsCount">
            <summary>
            The sum of all non null items.
            </summary>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentArray`1.Capacity">
            <summary>
            The total allocated space.
            </summary>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentArray`1.Drive">
            <summary>
            The allowed set of concurrent operations.
            </summary>
        </member>
        <member name="E:System.Collections.Concurrent.ConcurrentArray`1.OnGearShift">
            <summary>
            Will be triggered when the Drive changes. 
            The callbacks are invoked in a new Task, wrapped in try/catch block, 
            i.e. all exceptions are swallowed.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentArray`1.OnGearShiftReset">
            <summary>
            Clears the subscribers.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentArray`1.ShiftGear(System.Collections.Concurrent.ConcurrentArray{`0}.Gear,System.Action,System.Int32)">
            <summary>
            Blocks until the gear is shifted. 
            </summary>
            <param name="g">The new concurrent mode.</param>
            <param name="f">Guarantees the execution of f() within the lock scope, in case that other shifts are waiting.</param>
            <param name="timeout">In milliseconds, by default is -1, which is indefinitely.</param>
            <returns>The old gear.</returns>
            <exception cref="T:System.SynchronizationException">Code.SignalAwaitTimeout</exception>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentArray`1.Item(System.Int32)">
            <summary>
            Access to the individual cells.
            </summary>
            <param name="index">Must be less than AppendIndex</param>
            <returns>The object reference at the index</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">index</exception>
            <exception cref="T:System.InvalidOperationException">If the Drive is wrong</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentArray`1.Take(System.Int32)">
            <summary>
            Takes the item at index and swaps it with null as one atomic operation.
            </summary>
            <remarks>
            One can use Take() and Append() in multi-producer, multi-consumer scenarios, since both are safe,
            </remarks>
            <param name="index">The position in the array, must be less than AppendIndex.</param>
            <returns>The reference at index.</returns>
            <exception cref="T:System.InvalidOperationException">When Drive is P.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentArray`1.Append(`0)">
            <summary>
            Appends an item after the AppendIndex. 
            If there is not enough space locks until enough blocks are
            allocated and then switches back to fully concurrent mode.
            </summary>
            <param name="item">The object reference</param>
            <returns>The index of the item, -1 if fails.</returns>
            <exception cref="T:System.InvalidOperationException">When Drive != Gear.Straight</exception>
            <exception cref="T:System.InvariantException">On attempt to append beyond TotalMaxCapacity.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentArray`1.RemoveLast(System.Int32@)">
            <summary>
            Nulls the AppendIndex cell, decrements the AppendIndex value and returns the item that was there.
            </summary>
            <param name="pos">The item position.</param>
            <returns>The removed item.</returns>
            <exception cref="T:System.InvalidOperationException">When Drive != Gear.Reverse</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentArray`1.Remove(`0)">
            <summary>
            Looks for the item and nulls the array cell.
            </summary>
            <param name="item">The object reference</param>
            <returns>True if found and null-ed</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentArray`1.Items">
            <summary>
            Iterates all cells from 0 up to AppendIndex and yields the  item if it's not null at the time of the check.
            </summary>
            <returns>A not null item.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentArray`1.IndexOf(`0)">
            <summary>
            Searches for an item by traversing all cells up to AppendIndex.
            </summary>
            <param name="item">The object ref</param>
            <returns>A positive value if the item is found, -1 otherwise.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentArray`1.Resize(System.Int32,System.Boolean)">
            <summary>
            Expands or shrinks the virtual array to the number of base-length tiles fitting the requested length.
            If the AppendIndex is greater that the new length, it's cut to length -1.
            If shrinking, the number of not-null values, i.e. ItemsCount is also updated.
            </summary>
            <param name="length">The new length.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">If length is negative</exception>
            <exception cref="T:System.InvalidOperationException">When Drive != Gear.P </exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentArray`1.Format(`0)">
            <summary>
            Sets the provided item ref or null to all available cells.
            The Drive must be either N or Straight, meaning that 
            there is a race with Append() and set.
            The method is synchronized.
            </summary>
            <param name="item">The ref to be set</param>
            <exception cref="T:System.InvalidOperationException">Drive is not N or Straight</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentArray`1.MoveAppendIndex(System.Int32,System.Boolean)">
            <summary>
            Moves the AppendIndex to a new location, which must be and less than Capacity.
            </summary>
            <param name="newIndex">The new index.</param>
            <param name="forced">If true, blindly swaps the AppendIndex with the newIndex, regardless
            of the Drive mode.</param>
        </member>
        <member name="F:System.Collections.Concurrent.ConcurrentArray`1.ExpansionLength">
            <summary>
            Will be called before allocating more space, providing the current length as an argument.
            The returned value is desired new total length.
            The default growth factor is 2.
            </summary>
            <remarks>
            By providing different growth factors depending on the current size,
            one can create different allocation size vs. capacity curves.
            </remarks>
        </member>
        <member name="T:System.HeapFragment">
            <summary>
            Represents a slice of a heap allocated buffer
            </summary>
        </member>
        <member name="M:System.HeapFragment.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>Writes the bytes in data into the heap fragment.</summary>
            <param name="data">The bytes to be written</param>
            <param name="offset">The writing position in the fragment window.</param>
            <param name="length">The amount of bytes to take from <c>data</c> (0-length).</param>
            <returns>The new offset, i.e. <c>offset + length</c>.</returns>
            <exception cref="T:System.ArgumentNullException">If data is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If offset and length are out of range.</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks is on: 
            AttemptToAccessWrongLaneCycle, AttemptToAccessDisposedLane, AttemptToAccessClosedLane
            </exception>
        </member>
        <member name="M:System.HeapFragment.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads bytes from a MMF starting at offset and reading as long as <c>destination</c> is not filled up. 
            The writing starts at destOffset and ends either at destination.Length or at fragment.Length - offset.
            </summary>
            <param name="destination">The buffer where the MMF data goes to.</param>
            <param name="offset">The reading starts at offset.</param>
            <param name="destOffset">The writing starts at destOffset.</param>
            <returns>The new reading position = offset + the read bytes notNullsCount.</returns>
            <exception cref="T:System.ArgumentNullException">If destination is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">For offset and destOffset.</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks is on: 
            AttemptToAccessWrongLaneCycle, AttemptToAccessDisposedLane, AttemptToAccessClosedLane
            </exception>
        </member>
        <member name="P:System.HeapFragment.UseAccessChecks">
            <summary>
            Guards against accessing a disposed, closed or reset lane.
            The default is true.
            </summary>
        </member>
        <member name="M:System.HeapFragment.Span">
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks is on: 
            AttemptToAccessWrongLaneCycle, AttemptToAccessDisposedLane, AttemptToAccessClosedLane
            </exception>
        </member>
        <member name="T:System.MappedFragment">
            <summary>
            Represents a fragment of a memory mapped file.
            </summary>
        </member>
        <member name="M:System.MappedFragment.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>Writes the bytes in data into the MMF.</summary>
            <remarks>Note that the Read() and Write() methods are not synchronized with access trough Span().
            Use either Read/Write or Span().</remarks>
            <param name="data">The bytes to be written</param>
            <param name="offset">The number of written bytes so far.</param>
            <param name="length">The amount of bytes to take from data (takes from 0 to length).</param>
            <returns>The total written bytes, i.e. offset + length.</returns>
            <exception cref="T:System.ArgumentNullException">If data is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If offset and length are out of range.</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks is on: 
            AttemptToAccessWrongLaneCycle, AttemptToAccessDisposedLane, AttemptToAccessClosedLane
            </exception>
        </member>
        <member name="M:System.MappedFragment.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads bytes from a MMF starting at offset and reading as long as <c>destination</c> is not filled up. 
            The writing starts at destOffset and ends either at destination.Length or at fragment.Length - offset.
            </summary>
            <param name="destination">The buffer where the MMF data goes to.</param>
            <param name="offset">The total read bytes so far.</param>
            <param name="destOffset">Index in destination where the copying will begin at. By default is 0.</param>
            <returns>The total bytes read from the MMF, i.e. the new offset.</returns>
            <exception cref="T:System.ArgumentNullException">If destination is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">For offset and destOffset.</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks is on: 
            AttemptToAccessWrongLaneCycle, AttemptToAccessDisposedLane, AttemptToAccessClosedLane
            </exception>
        </member>
        <member name="M:System.MappedFragment.Span">
            <summary>
            Creates a Span from a raw pointer which marks the beginning of the 
            MemoryMappedViewAccessor window.
            </summary>
            <returns>A Span structure</returns>
             <exception cref="T:System.MemoryLaneException">If UseAccessChecks is on: 
            AttemptToAccessWrongLaneCycle, AttemptToAccessDisposedLane, AttemptToAccessClosedLane
            </exception>
        </member>
        <member name="M:System.MappedFragment.Dispose">
            <summary>
            Does not implement a finalizer because the resource is held by the lane.
            </summary>
        </member>
        <member name="P:System.MappedFragment.UseAccessChecks">
            <summary>
            Guards against accessing a disposed, closed or reset lane.
            The default is true.
            </summary>
        </member>
        <member name="F:System.MappedFragment.StartIdx">
            <summary>
            The byte offset in the MMF where the fragment starts.
            </summary>
        </member>
        <member name="F:System.MappedFragment.length">
            <summary>
            The length of the fragment. 
            </summary>
        </member>
        <member name="T:System.MarshalLaneFragment">
            <summary>
            Represents a slice of a MemoryLane allocated via Marshal.AllocHGlobal
            </summary>
        </member>
        <member name="M:System.MarshalLaneFragment.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes the bytes in data (0-length) to the underlying native memory region starting at <c>offset</c> position.
            </summary>
            <param name="data">The source array.</param>
            <param name="offset">The writing position in the native fragment</param>
            <param name="length">How many bytes from the source to take.</param>
            <returns>The offset + length</returns>
            <exception cref="T:System.ArgumentNullException">data</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">For offset and length.</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks is on: 
            AttemptToAccessWrongLaneCycle,
            AttemptToAccessDisposedLane,
            AttemptToAccessClosedLane
            </exception>
        </member>
        <member name="M:System.MarshalLaneFragment.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads bytes from native memory starting at offset (within the fragment region) and reads until 
            <c>destination</c> is full or there is no more data.
            The writing in <c>destination</c> starts at destOffset.
            </summary>
            <param name="destination">The read data.</param>
            <param name="offset">The position in source to begin reading from.</param>
            <param name="destOffset">Index in destination where the copying will begin at. By default is 0.</param>
            <returns>The total bytes read, i.e. the new offset.</returns>
            <exception cref="T:System.ArgumentNullException">If destination is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">For offset and destOffset.</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks is on: 
            AttemptToAccessWrongLaneCycle,
            AttemptToAccessDisposedLane,
            AttemptToAccessClosedLane
            </exception>
        </member>
        <member name="M:System.MarshalLaneFragment.Span">
            <summary>
            Creates a Span from a raw pointer marking the beginning of the fragment window.
            </summary>
            <returns>A Span structure</returns>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks is on: 
            AttemptToAccessWrongLaneCycle,
            AttemptToAccessDisposedLane,
            AttemptToAccessClosedLane
            </exception>
        </member>
        <member name="M:System.MarshalLaneFragment.Dispose">
            <summary>
            Does not implement a finalizer because the resource is held by the lane.
            </summary>
        </member>
        <member name="P:System.MarshalLaneFragment.UseAccessChecks">
            <summary>
            Guards against accessing a disposed, closed or reset lane.
            The default is true.
            </summary>
        </member>
        <member name="F:System.MarshalLaneFragment.StartIdx">
            <summary>
            The beginning position within the MarshalLane
            </summary>
        </member>
        <member name="F:System.MarshalLaneFragment.length">
            <summary>
            The length of the fragment. 
            </summary>
        </member>
        <member name="T:System.MarshalSlot">
            <summary>
            Represents a slice of unmanaged memory. 
            This object is not part of a MemoryLane and its lifetime does not affect other MemoryFragment instances.
            Use the MarshalSlot for large and/or long living data, which would fragment the memory lanes 
            by preventing reset, or burden the GC and the managed heap if allocated there.
            </summary>
            <remarks>
            This class has multiple accessors with different meaning and one should be careful not to mix the Read/Writes 
            with Span() and the Store/Load/Reserve methods.
            </remarks>
        </member>
        <member name="M:System.MarshalSlot.Span(System.Boolean)">
            <summary>
            Take a Span of the whole range.
            </summary>
            <param name="format">Zero the bytes</param>
            <returns>The Span</returns>
        </member>
        <member name="M:System.MarshalSlot.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes the bytes in data (0-length) to the underlying native memory region starting at <c>offset</c> position.
            </summary>
            <param name="data">The source array.</param>
            <param name="offset">The writing position in the native fragment</param>
            <param name="length">How many bytes from the source to take.</param>
            <returns>The offset + length</returns>
        </member>
        <member name="M:System.MarshalSlot.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads bytes from native memory starting at offset (within the fragment region) and reads until 
            <c>destination</c> is full or there is no more data.
            The writing in <c>destination</c> starts at destOffset.
            </summary>
            <param name="destination">The read data.</param>
            <param name="offset">The position in source to begin reading from.</param>
            <param name="destOffset">Index in destination where the copying will begin at. By default is 0.</param>
            <returns>The total bytes read, i.e. the new offset.</returns>
            <exception cref="T:System.ArgumentNullException">If destination is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">For offset and destOffset.</exception>
        </member>
        <member name="M:System.MarshalSlot.Store``1(``0)">
            <summary>
            Store an unmanaged structure which has no managed references. 
            </summary>
            <typeparam name="T">Unmanaged structure type</typeparam>
            <param name="str">The value</param>
            <returns></returns>
        </member>
        <member name="M:System.MarshalSlot.Reserve``1(System.MarshalSlot@)">
            <summary>
            Returns a pointer to a structure, allocated in unmanaged memory.
            </summary>
            <typeparam name="T">A ref-free type.</typeparam>
            <param name="mps">The pointer holder.</param>
            <returns></returns>
        </member>
        <member name="M:System.MarshalSlot.Load``1">
            <summary>
            Constructs previously stored unmanaged structure.
            </summary>
            <typeparam name="T">A reference free structure type</typeparam>
            <returns>The initialized structure</returns>
        </member>
        <member name="M:System.MarshalSlot.Dispose">
            <summary>
            Does not implement a finalizer!
            </summary>
        </member>
        <member name="P:System.MemoryFragment.Item(System.Int32)">
            <summary>
            Gets or sets a byte at index.
            </summary>
            <param name="index">The index</param>
            <returns>The value at index</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If index is out of range</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks and the lane is closed or cycled.
            Codes: AttemptToAccessWrongLaneCycle, AttemptToAccessClosedLane AttemptToAccessDisposedLane</exception>
        </member>
        <member name="M:System.MemoryFragment.Write(System.Byte,System.Int32)">
            <summary>
            Writes the value starting at startpos.
            </summary>
            <param name="v">The value</param>
            <param name="startpos">The index in the fragment window.</param>
            <returns>The new offset, i.e. startpos + the value length in bytes. If fails returns -startpos.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If startpos is out of range</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks and the lane is closed or cycled.
            Codes: AttemptToAccessWrongLaneCycle, AttemptToAccessClosedLane AttemptToAccessDisposedLane</exception>
        </member>
        <member name="M:System.MemoryFragment.Write(System.Boolean,System.Int32)">
            <summary>
            Writes the value starting at startpos.
            </summary>
            <param name="v">The value</param>
            <param name="startpos">The index in the fragment window.</param>
            <returns>The new offset, i.e. startpos + the value length in bytes. If fails returns -startpos.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If startpos is out of range</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks and the lane is closed or cycled.
            Codes: AttemptToAccessWrongLaneCycle, AttemptToAccessClosedLane AttemptToAccessDisposedLane</exception>
        </member>
        <member name="M:System.MemoryFragment.Write(System.Char,System.Int32)">
            <summary>
            Writes the value starting at startpos.
            </summary>
            <param name="v">The value</param>
            <param name="startpos">The index in the fragment window.</param>
            <returns>The new offset, i.e. startpos + the value length in bytes. If fails returns -startpos.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If startpos is out of range</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks and the lane is closed or cycled.
            Codes: AttemptToAccessWrongLaneCycle, AttemptToAccessClosedLane AttemptToAccessDisposedLane</exception>
        </member>
        <member name="M:System.MemoryFragment.Write(System.Int16,System.Int32)">
            <summary>
            Writes the value starting at startpos.
            </summary>
            <param name="v">The value</param>
            <param name="startpos">The index in the fragment window.</param>
            <returns>The new offset, i.e. startpos + the value length in bytes. If fails returns -startpos.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If startpos is out of range</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks and the lane is closed or cycled.
            Codes: AttemptToAccessWrongLaneCycle, AttemptToAccessClosedLane AttemptToAccessDisposedLane</exception>
        </member>
        <member name="M:System.MemoryFragment.Write(System.Int32,System.Int32)">
            <summary>
            Writes the value starting at startpos.
            </summary>
            <param name="v">The value</param>
            <param name="startpos">The index in the fragment window.</param>
            <returns>The new offset, i.e. startpos + the value length in bytes. If fails returns -startpos.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If startpos is out of range</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks and the lane is closed or cycled.
            Codes: AttemptToAccessWrongLaneCycle, AttemptToAccessClosedLane AttemptToAccessDisposedLane</exception>
        </member>
        <member name="M:System.MemoryFragment.Write(System.UInt32,System.Int32)">
            <summary>
            Writes the value starting at startpos.
            </summary>
            <param name="v">The value</param>
            <param name="startpos">The index in the fragment window.</param>
            <returns>The new offset, i.e. startpos + the value length in bytes. If fails returns -startpos.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If startpos is out of range</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks and the lane is closed or cycled.
            Codes: AttemptToAccessWrongLaneCycle, AttemptToAccessClosedLane AttemptToAccessDisposedLane</exception>
        </member>
        <member name="M:System.MemoryFragment.Write(System.Int64,System.Int32)">
            <summary>
            Writes the value starting at startpos.
            </summary>
            <param name="v">The value</param>
            <param name="startpos">The index in the fragment window.</param>
            <returns>The new offset, i.e. startpos + the value length in bytes. If fails returns -startpos.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If startpos is out of range</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks and the lane is closed or cycled.
            Codes: AttemptToAccessWrongLaneCycle, AttemptToAccessClosedLane AttemptToAccessDisposedLane</exception>
        </member>
        <member name="M:System.MemoryFragment.Write(System.UInt64,System.Int32)">
            <summary>
            Writes the value starting at startpos.
            </summary>
            <param name="v">The value</param>
            <param name="startpos">The index in the fragment window.</param>
            <returns>The new offset, i.e. startpos + the value length in bytes. If fails returns -startpos.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If startpos is out of range</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks and the lane is closed or cycled.
            Codes: AttemptToAccessWrongLaneCycle, AttemptToAccessClosedLane AttemptToAccessDisposedLane</exception>
        </member>
        <member name="M:System.MemoryFragment.Write(System.Double,System.Int32)">
            <summary>
            Writes the value starting at startpos.
            </summary>
            <param name="v">The value</param>
            <param name="startpos">The index in the fragment window.</param>
            <returns>The new offset, i.e. startpos + the value length in bytes. If fails returns -startpos.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If startpos is out of range</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks and the lane is closed or cycled.
            Codes: AttemptToAccessWrongLaneCycle, AttemptToAccessClosedLane AttemptToAccessDisposedLane</exception>
        </member>
        <member name="M:System.MemoryFragment.Write(System.Guid,System.Int32)">
            <summary>
            Writes the value starting at startpos.
            </summary>
            <param name="v">The value</param>
            <param name="startpos">The index in the fragment window.</param>
            <returns>The new offset, i.e. startpos + the value length in bytes. If fails returns -startpos.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If startpos is out of range</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks and the lane is closed or cycled.
            Codes: AttemptToAccessWrongLaneCycle, AttemptToAccessClosedLane AttemptToAccessDisposedLane</exception>
        </member>
        <member name="M:System.MemoryFragment.Write(System.DateTime,System.Int32)">
            <summary>
            Writes the value starting at startpos.
            </summary>
            <param name="v">The value</param>
            <param name="startpos">The index in the fragment window.</param>
            <returns>The new offset, i.e. startpos + the value length in bytes. If fails returns -startpos.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If startpos is out of range</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks and the lane is closed or cycled.
            Codes: AttemptToAccessWrongLaneCycle, AttemptToAccessClosedLane AttemptToAccessDisposedLane</exception>
        </member>
        <member name="M:System.MemoryFragment.Write(System.Span{System.Byte},System.Int32)">
            <summary>
            Copies the span starting at startpos.
            </summary>
            <param name="bytes">The span to be copied</param>
            <param name="startpos">The index in the fragment window.</param>
            <returns>The new offset, i.e. startpos + the span length. If fails returns -startpos.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If startpos is out of range</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks and the lane is closed or cycled.
            Codes: AttemptToAccessWrongLaneCycle, AttemptToAccessClosedLane AttemptToAccessDisposedLane</exception>
        </member>
        <member name="M:System.MemoryFragment.Read(System.Byte@,System.Int32)">
            <summary>
            Reads the value starting at startpos.
            </summary>
            <param name="v">The ref value to be updated.</param>
            <param name="startpos">Index in the fragment window.</param>
            <returns>The updated position as startpos + the value length.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If startpos is out of range</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks and the lane is closed or cycled.
            Codes: AttemptToAccessWrongLaneCycle, AttemptToAccessClosedLane AttemptToAccessDisposedLane</exception>
        </member>
        <member name="M:System.MemoryFragment.Read(System.Boolean@,System.Int32)">
            <summary>
            Reads the value starting at startpos.
            </summary>
            <param name="v">The ref value to be updated.</param>
            <param name="startpos">Index in the fragment window.</param>
            <returns>The updated position as startpos + the value length.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If startpos is out of range</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks and the lane is closed or cycled.
            Codes: AttemptToAccessWrongLaneCycle, AttemptToAccessClosedLane AttemptToAccessDisposedLane</exception>
        </member>
        <member name="M:System.MemoryFragment.Read(System.Char@,System.Int32)">
            <summary>
            Reads the value starting at startpos.
            </summary>
            <param name="v">The ref value to be updated.</param>
            <param name="startpos">Index in the fragment window.</param>
            <returns>The updated position as startpos + the value length.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If startpos is out of range</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks and the lane is closed or cycled.
            Codes: AttemptToAccessWrongLaneCycle, AttemptToAccessClosedLane AttemptToAccessDisposedLane</exception>
        </member>
        <member name="M:System.MemoryFragment.Read(System.Int16@,System.Int32)">
            <summary>
            Reads the value starting at startpos.
            </summary>
            <param name="v">The ref value to be updated.</param>
            <param name="startpos">Index in the fragment window.</param>
            <returns>The updated position as startpos + the value length.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If startpos is out of range</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks and the lane is closed or cycled.
            Codes: AttemptToAccessWrongLaneCycle, AttemptToAccessClosedLane AttemptToAccessDisposedLane</exception>
        </member>
        <member name="M:System.MemoryFragment.Read(System.Int32@,System.Int32)">
            <summary>
            Reads the value starting at startpos.
            </summary>
            <param name="v">The ref value to be updated.</param>
            <param name="startpos">Index in the fragment window.</param>
            <returns>The updated position as startpos + the value length.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If startpos is out of range</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks and the lane is closed or cycled.
            Codes: AttemptToAccessWrongLaneCycle, AttemptToAccessClosedLane AttemptToAccessDisposedLane</exception>
        </member>
        <member name="M:System.MemoryFragment.Read(System.UInt32@,System.Int32)">
            <summary>
            Reads the value starting at startpos.
            </summary>
            <param name="v">The ref value to be updated.</param>
            <param name="startpos">Index in the fragment window.</param>
            <returns>The updated position as startpos + the value length.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If startpos is out of range</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks and the lane is closed or cycled.
            Codes: AttemptToAccessWrongLaneCycle, AttemptToAccessClosedLane AttemptToAccessDisposedLane</exception>
        </member>
        <member name="M:System.MemoryFragment.Read(System.Int64@,System.Int32)">
            <summary>
            Reads the value starting at startpos.
            </summary>
            <param name="v">The ref value to be updated.</param>
            <param name="startpos">Index in the fragment window.</param>
            <returns>The updated position as startpos + the value length.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If startpos is out of range</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks and the lane is closed or cycled.
            Codes: AttemptToAccessWrongLaneCycle, AttemptToAccessClosedLane AttemptToAccessDisposedLane</exception>
        </member>
        <member name="M:System.MemoryFragment.Read(System.UInt64@,System.Int32)">
            <summary>
            Reads the value starting at startpos.
            </summary>
            <param name="v">The ref value to be updated.</param>
            <param name="startpos">Index in the fragment window.</param>
            <returns>The updated position as startpos + the value length.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If startpos is out of range</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks and the lane is closed or cycled.
            Codes: AttemptToAccessWrongLaneCycle, AttemptToAccessClosedLane AttemptToAccessDisposedLane</exception>
        </member>
        <member name="M:System.MemoryFragment.Read(System.Double@,System.Int32)">
            <summary>
            Reads the value starting at startpos.
            </summary>
            <param name="v">The ref value to be updated.</param>
            <param name="startpos">Index in the fragment window.</param>
            <returns>The updated position as startpos + the value length.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If startpos is out of range</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks and the lane is closed or cycled.
            Codes: AttemptToAccessWrongLaneCycle, AttemptToAccessClosedLane AttemptToAccessDisposedLane</exception>
        </member>
        <member name="M:System.MemoryFragment.Read(System.Guid@,System.Int32)">
            <summary>
            Reads the value starting at startpos.
            </summary>
            <param name="v">The ref value to be updated.</param>
            <param name="startpos">Index in the fragment window.</param>
            <returns>The updated position as startpos + the value length.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If startpos is out of range</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks and the lane is closed or cycled.
            Codes: AttemptToAccessWrongLaneCycle, AttemptToAccessClosedLane AttemptToAccessDisposedLane</exception>
        </member>
        <member name="M:System.MemoryFragment.Read(System.DateTime@,System.Int32)">
            <summary>
            Reads the value starting at startpos.
            </summary>
            <param name="v">The ref value to be updated.</param>
            <param name="startpos">Index in the fragment window.</param>
            <returns>The updated position as startpos + the value length.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If startpos is out of range</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks and the lane is closed or cycled.
            Codes: AttemptToAccessWrongLaneCycle, AttemptToAccessClosedLane AttemptToAccessDisposedLane</exception>
        </member>
        <member name="M:System.MemoryFragment.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>Writes the bytes in data into the fragment storage.</summary>
            <param name="data">The bytes to be written</param>
            <param name="offset">The writing position in the fragment window.</param>
            <param name="length">The amount of bytes to take from <c>data</c> (0-length).</param>
            <returns>The new offset, i.e. <c>offset + length</c>.</returns>
            <exception cref="T:System.ArgumentNullException">If data is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If offset and length are out of range.</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks is on: 
            AttemptToAccessWrongLaneCycle, AttemptToAccessDisposedLane, AttemptToAccessClosedLane
            </exception>
        </member>
        <member name="M:System.MemoryFragment.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads bytes from the fragment storage starting at offset and reading as long as <c>destination</c> is not filled up. 
            The writing starts at destOffset and ends either at destination.Length or at fragment.Length - offset.
            </summary>
            <param name="destination">The read buffer.</param>
            <param name="offset">The reading starts at offset.</param>
            <param name="destOffset">The writing starts at destOffset.</param>
            <returns>The new reading position = offset + the read bytes notNullsCount.</returns>
            <exception cref="T:System.ArgumentNullException">If destination is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">For offset and destOffset.</exception>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks is on: 
            AttemptToAccessWrongLaneCycle, AttemptToAccessDisposedLane, AttemptToAccessClosedLane
            </exception>
        </member>
        <member name="F:System.MemoryFragment.useAccessChecks">
            <summary>
            If true checks whether the lane is closed, disposed or the cycle has not changed.
            Derived classes may expose it as public, by default is true.
            </summary>
        </member>
        <member name="M:System.MemoryFragment.op_Implicit(System.MemoryFragment)~System.Span{System.Byte}">
            <summary>
            Gets the fragment Span. 
            </summary>
            <param name="f">The fragment.</param>
            <exception cref="T:System.MemoryLaneException">If UseAccessChecks is on: 
            AttemptToAccessWrongLaneCycle, AttemptToAccessDisposedLane, AttemptToAccessClosedLane
            </exception>
        </member>
        <member name="T:System.HeapHighway">
            <summary>
            Allocates memory lanes on the large object heap (if the length is > 80K).
            </summary>
        </member>
        <member name="M:System.HeapHighway.#ctor">
            <summary>
            Creates a 2 lane highway with lengths 8MB and 4MB
            </summary>
        </member>
        <member name="M:System.HeapHighway.#ctor(System.Int32[])">
            <summary>
            Creates new lanes with the specified lengths and a default MemoryLaneSettings instance.
            </summary>
            <param name="lanes">The initial layout.</param>
        </member>
        <member name="M:System.HeapHighway.#ctor(System.MemoryLaneSettings,System.Int32[])">
            <summary>
            Creates new lanes with the specified lengths and settings.
            When needed, the MemoryCarriage will create the new lanes with settings.DefaultCapacity in length.
            </summary>
            <param name="stg">Generic settings for all MemoryCarriage derivatives.</param>
            <param name="lanes">The initial setup.</param>
        </member>
        <member name="T:System.MappedHighway">
            <summary>
            Allocates memory lanes as memory mapped files - one lane is one file.
            </summary>
        </member>
        <member name="M:System.MappedHighway.#ctor">
            <summary>
            Creates a 2 lane highway with lengths 8MB and 4MB
            </summary>
        </member>
        <member name="M:System.MappedHighway.#ctor(System.Int32[])">
            <summary>
            Creates new lanes with the specified lengths and a default MemoryLaneSettings instance.
            Note that every lane is one memory mapped file.
            </summary>
            <param name="lanes">The initial layout.</param>
        </member>
        <member name="M:System.MappedHighway.#ctor(System.MemoryLaneSettings,System.Int32[])">
            <summary>
            Creates new lanes with the specified lengths and settings.
            When needed, the MemoryCarriage will create the new lanes with settings.DefaultCapacity in length.
            Note that every lane is a separate memory mapped file.
            </summary>
            <param name="stg">Generic settings for all MemoryCarriage derivatives.</param>
            <param name="lanes">The initial setup.</param>
        </member>
        <member name="T:System.MarshalHighway">
            <summary>
            Allocates memory lanes via Marshal.AllocHGlobal
            </summary>
        </member>
        <member name="M:System.MarshalHighway.#ctor">
            <summary>
            Creates a 2 lane highway with lengths 8MB and 4MB
            </summary>
        </member>
        <member name="M:System.MarshalHighway.#ctor(System.Int32[])">
            <summary>
            Creates new lanes with the specified lengths and a default MemoryLaneSettings instance.
            </summary>
            <param name="lanes">The initial layout.</param>
        </member>
        <member name="M:System.MarshalHighway.#ctor(System.MemoryLaneSettings,System.Int32[])">
            <summary>
            Creates new lanes with the specified lengths and settings.
            When needed, the MemoryCarriage will create the new lanes with settings.DefaultCapacity in length.
            </summary>
            <param name="stg">Generic settings for all MemoryCarriage derivatives.</param>
            <param name="lanes">The initial setup.</param>
        </member>
        <member name="T:System.MemoryCarriage`2">
            <summary>
            The allocation/release behavior is generalized here.
            </summary>
            <typeparam name="L">A Lane</typeparam>
            <typeparam name="F">The corresponding fragment type</typeparam>
        </member>
        <member name="M:System.MemoryCarriage`2.Create(System.Int32)">
            <summary>
            Creates new lanes with the default capacity from the MemoryLaneSettings. 
            </summary>
            <param name="count">Number of lanes to create.</param>
            <exception cref="T:System.MemoryLaneException">
            Code.MaxLanesCountReached: when the MaxLanesCountReached threshold in settings is reached AND
            the OnMaxLaneReached handler is either null or returns false
            Code.MaxTotalAllocBytesReached: when the total lanes capacity is greater than MaxTotalAllocatedBytes AND
            the OnMaxTotalBytesReached handler is either null or returns false, meaning "do not ignore".
            Code.SizeOutOfRange: when at least one of the lengths is outside the 
            MemoryLaneSettings.MIN_CAPACITY - MemoryLaneSettings.MAX_CAPACITY interval.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If notNullsCount is outside the 1-MemoryLaneSettings.MAX_COUNT interval </exception>
        </member>
        <member name="M:System.MemoryCarriage`2.Create(System.Int32[])">
            <summary>
            Creates new lanes with specific capacities. 
            </summary>
            <param name="laneSizes">Lanes by length.</param>
            <exception cref="T:System.MemoryLaneException">
            Code.MaxLanesCountReached: when the MaxLanesCountReached threshold in settings is reached AND
            the OnMaxLaneReached handler is either null or returns false
            Code.MaxTotalAllocBytesReached: when the total lanes capacity is greater than MaxTotalAllocatedBytes AND
            the OnMaxTotalBytesReached handler is either null or returns false, meaning "do not ignore".
            Code.SizeOutOfRange: when at least one of the lengths is outside the 
            MemoryLaneSettings.MIN_CAPACITY - MemoryLaneSettings.MAX_CAPACITY interval.
            </exception>
            <exception cref="T:System.ArgumentNullException">When the laneSizes is either null or has zero items.</exception>
        </member>
        <member name="M:System.MemoryCarriage`2.Alloc(System.Int32,System.Int32)">
            <summary>
            Allocates a generic fragment with a specified length.
            </summary>
            <param name="size">The number of bytes to allocate.</param>
            <param name="awaitMS">The lane lock await in milliseconds, by default awaits forever (-1)</param>
            <returns>The fragment structure.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If size is negative or greater than MemoryLaneSettings.MAX_CAPACITY.
            </exception>
            <exception cref="T:System.MemoryLaneException">
            Code.NotInitialized: when the lanes are not initialized.
            Code.NewLaneAllocFail: after an unsuccessful attempt to allocate a fragment in a dedicated new lane.
            One should never see this one!
            </exception>
        </member>
        <member name="M:System.MemoryCarriage`2.AllocFragment(System.Int32,System.Int32)">
            <summary>
            Allocates a memory fragment on any of the existing lanes or on a new one.
            By default the allocation awaits other allocations on the same lane, pass awaitMS > 0 in
            order to skip a lane. Note however than the MemoryLaneSettings.NoWaitLapsBeforeNewLane controls
            how many cycles around all lanes should be made before allocating a new lane.
            </summary>
            <param name="size">The desired buffer length.</param>
            <param name="awaitMS">By default the allocation awaits other allocations on the same lane.</param>
            <returns></returns>
        </member>
        <member name="M:System.MemoryCarriage`2.GetTotalActiveFragments">
            <summary>
            Returns an aggregate of all active fragments in all lanes.
            </summary>
            <returns>The number of active fragments</returns>
        </member>
        <member name="M:System.MemoryCarriage`2.GetTotalCapacity">
            <summary>
            Sums the lengths of all lanes.
            </summary>
            <returns>The total preallocated space for the highway.</returns>
        </member>
        <member name="M:System.MemoryCarriage`2.GetTotalFreeSpace">
            <summary>
            Sums the free space in all lanes.
            </summary>
            <returns>The total bytes left.</returns>
        </member>
        <member name="M:System.MemoryCarriage`2.GetLanesCount">
            <summary>
            Gets the Lanes notNullsCount.
            </summary>
            <returns>The number of preallocated lanes.</returns>
        </member>
        <member name="M:System.MemoryCarriage`2.GetLastLaneIndex">
            <summary>
            Returns the array.AppendIndex value, i.e. the furthest index in the Lanes array.
            </summary>
            <returns>The number of preallocated lanes.</returns>
        </member>
        <member name="M:System.MemoryCarriage`2.GetLanes">
            <summary>
            Creates a new List instance with the selection of all non null cells in the underlying array.
            This is a relatively expensive operation, depending on the array length and the AppendIndex value, so
            one may consider using the indexer instead.
            </summary>
            <returns>A read only list of MemoryLane objects.</returns>
        </member>
        <member name="P:System.MemoryCarriage`2.Item(System.Int32)">
            <summary>
            Get a specific lane.
            </summary>
            <param name="index">The index must be less than the LastLaneIndex value. </param>
            <returns>The Lane</returns>
        </member>
        <member name="M:System.MemoryCarriage`2.FreeGhosts">
            <summary>
            Triggers FreeGhosts() on all lanes.
            </summary>
        </member>
        <member name="P:System.MemoryCarriage`2.LastAllocTickAnyLane">
            <summary>
            Use to detect bad disposal behavior. 
            </summary>
        </member>
        <member name="T:System.MemoryLane.DisposalMode">
            <summary>
            Determines the way lanes deal with fragment deallocation.
            </summary>
        </member>
        <member name="F:System.MemoryLane.DisposalMode.IDispose">
            <summary>
            If the consumer forgets to call dispose on a fragment,
            the lane will never reset unless forced.
            </summary>
        </member>
        <member name="F:System.MemoryLane.DisposalMode.TrackGhosts">
            <summary>
            The lane will track all fragments into a special collection
            of weak refs, so when the GC collects the non-disposed fragments
            the lane can deallocate the correct amount and reset. 
            The triggering of the deallocation - FreeGhosts() is consumers responsibility.
            </summary>
        </member>
        <member name="M:System.MemoryLane.FreeGhosts">
            <summary>
            Triggers deallocation of the tracked not-disposed and GC collected fragments. 
            Does nothing if the fragments are still alive. 
            </summary>
            <remarks>
            This method is racing both the allocations and the reset. If the lane is reset 
            FreeGhosts() returns immediately. The check is made on every iteration before the resetOne() call.
            </remarks>
            <returns>The number of deallocations.</returns>
            <exception cref="T:System.MemoryLaneException">Code: IncorrectDisposalMode</exception>
        </member>
        <member name="M:System.MemoryLane.free(System.Int32,System.Int32)">
            <summary>
            Free is called from the fragment's Dispose method.
            </summary>
            <param name="cycle">The lane cycle given to the fragment at creation time.</param>
        </member>
        <member name="M:System.MemoryLane.Force(System.Boolean,System.Boolean)">
            <summary>
            Resets the offset and allocations of the lane or closes the lane or all at once (one lock).
            </summary>
            <remarks>
            Resetting the offset may lead to unpredictable behavior if you attempt to read or write
            with any active fragments. The MemoryFragment's Read/Write and Span() methods assert the 
            correctness of the lane cycle, but one may already have a Span for the previous cycle,
            and using it will override the lane on write and yield corrupt data on read.
            </remarks>
            <param name="close">True to close the lane.</param>
            <param name="reset">True to reset the offset and the allocations to 0.</param>
        </member>
        <member name="M:System.MemoryLane.FullTrace">
            <summary>
            Traces the Allocations, LaneCycle, Capacity, Offset, LasrtAllocTick and IsClosed properties.
            </summary>
            <returns>A formatted string: [offset/cap #allocations C:LaneCycle T:lastAllocTick on/off]</returns>
        </member>
        <member name="F:System.MemoryLaneSettings.OnMaxLaneReached">
            <summary>
            Will be invoked if the MaxLanesCount threshold is reached.
            The MemoryCarriage would expect a boolean response indicating whether to swallow the 
            exception and return null as fragment or throw MemoryLaneException with code MaxLanesCountReached.
            </summary>
            <exception cref="T:System.MemoryLaneException">Code.MaxLanesCountReached</exception>
        </member>
        <member name="F:System.MemoryLaneSettings.OnMaxTotalBytesReached">
            <summary>
            A handler for the case of allocating more than MaxTotalAllocatedBytes in all lanes.
            Pass true in order to suppress the exception and just receive null as fragment.
            </summary>
            <exception cref="T:System.MemoryLaneException">Code.MaxTotalAllocBytesReached</exception>
        </member>
        <member name="F:System.MemoryLaneSettings.NextCapacity">
            <summary>
            If set, the function may specify different than the default capacity based on 
            the current number of lanes. By default always returns the DefaultCapacity value.
            </summary>
        </member>
        <member name="F:System.MemoryLaneSettings.NoWaitLapsBeforeNewLane">
            <summary>
            Controls how many full cycles around all lanes should be made and fail to enter the 
            lock with the specified awaitMS before creating a new lane.
            The default value is 2.
            </summary>
        </member>
        <member name="F:System.MemoryLaneSettings.DefaultCapacity">
            <summary>
            If the allocator fail to find a free slice in any lane, 
            a new one will be created with DefaultCapacity bytes in length.
            </summary>
        </member>
        <member name="F:System.MemoryLaneSettings.MaxLanesCount">
            <summary>
            Can be used with the OnMaxLaneReached handler as an alerting mechanism.
            </summary>
        </member>
        <member name="F:System.MemoryLaneSettings.MaxTotalAllocatedBytes">
            <summary>
            This is the aggregated capacity in all lanes, not the actual active fragments.
            </summary>
        </member>
        <member name="F:System.MemoryLaneSettings.RegisterForProcessExitCleanup">
            <summary>
            Will trigger a Dispose() before process exits. True by default.
            </summary>
        </member>
        <member name="F:System.MemoryLaneSettings.Disposal">
            <summary>
            Specifies the disposal mode.
            </summary>
        </member>
    </members>
</doc>
